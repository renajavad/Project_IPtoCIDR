# Перевод IP в CIDR  

IP-адрес – это отформатированное 32-битное число, состоящее из 4 блоков.  
Например, 15.136.255.107 – это 00001111 10001000 11111111 01101011  

CIDR-блок – это формат записи множеств айпи адресов. Он записывается в виде a.b.c.d/k, где k – это количество первых битов из IP-адреса, которые совпадают в множестве.
Остальные биты могут быть любыми, что и определяет это множество.  
Например, 123.45.67.89/20 – это множество IP-адресов вида 01111011 00101101 0100xxxx xxxxxxxx, где x – это либо 0, либо 1.  

# Условие  

На вход даётся IP-адрес и число n, характеризующее множество адресов.  
Например, ip = "255.0.0.7", n = 10 – это множество всех адресов от 255.0.0.7 до 255.0.0.16  
Задача - вывести CIDR блоки, которые покрывают полностью заданное множество, но не затрагивают никакие другие адреса.  

# Пример входных и выходных данных  

Вход: ip = "255.0.0.7", n = 10  
Выход: ["255.0.0.7/32", "255.0.0.8/29", "255.0.0.16/32"]  

# Пояснение  

Необходимо покрыть следующие адреса  
- 255.0.0.7 -> 11111111 00000000 00000000 00000111  
- 255.0.0.8 -> 11111111 00000000 00000000 00001000  
- 255.0.0.9 -> 11111111 00000000 00000000 00001001  
- 255.0.0.10 -> 11111111 00000000 00000000 00001010  
- 255.0.0.11 -> 11111111 00000000 00000000 00001011  
- 255.0.0.12 -> 11111111 00000000 00000000 00001100  
- 255.0.0.13 -> 11111111 00000000 00000000 00001101  
- 255.0.0.14 -> 11111111 00000000 00000000 00001110  
- 255.0.0.15 -> 11111111 00000000 00000000 00001111  
- 255.0.0.16 -> 11111111 00000000 00000000 00010000

CIDR-блок 255.0.0.7/32 покрывает первый адрес, CIDR-блок 255.0.0.8/29 покрывает 8 адресов посередине, CIDR-блок 255.0.0.16/32 покрывает последний адрес.  
CIDR-блок 255.0.0.0/28, например, покрывает все адреса, но при этом захватывает лишние, поэтому мы его НЕ берём.  

# Описание алгоритма  

Создаётся класс под названием IPtoCIDR, который преобразует IP-адрес в список блоков CIDR.  
В классе создаются публичные функции-члены :  
1. std::vector<std::string> finalResult(std::string IP, int n)
2. uint32_t StringtoInt(std::string IP)  
3. int countZeros(uint32_t IP)  
4. std::string InttoString(uint32_t IP)

Функция finalResult(std::string IP, int n) принимает IP-адрес в качестве входных данных и количество требуемых блоков и возвращает вектор строк, представляющих блоки CIDR.
Внутри этой функции в начале вызывается функция StringtoInt(IP), которая преобразует строковое представление IP-адреса в эквивалентную ему целочисленную форму.  
Далее в цикле while вызывается функция countZeros(IPint), которая подсчитывает количество последовательных нулей в двоичном представлении данного IP-адреса.  
Внутри цикла считывается префикс (prefix) CIDR блока и вызывается функция InttoString(IPint), которая преобразует 32-разрядный целочисленный IP-адрес в его строковое представление.  
Результат записывается в вектор строк через символ "/".  

# Сложность алгоритма  

- Преобразование строки IP-адреса в целочисленное представление выполняется за константное время. 
- Вычисление количества нулей IP-адреса выполняется за константное время.  
- Преобразование целочисленного значения в строковое выполняется за константное время.  
- Вычисление нового количества подсетей и префикса выполняется за O(nlogn).  
- Общая сложность алгоритма равна O(nlogn).
